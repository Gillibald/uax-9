#|
 This file is a part of UAX-9
 (c) 2019 Shirakumo http://tymoon.eu (shinmera@tymoon.eu)
 Author: Nicolas Hafner <shinmera@tymoon.eu>
|#

(in-package #:org.shirakumo.alloy.uax-9)

(declaim (inline type-for-level))
(defun type-for-level (level)
  (if (= 0 (logand #x1 level))
      (class-id :L)
      (class-id :R)))

(defstruct (seq (:constructor make-seq (indices types levels level sos eos))
                (:copier NIL))
  (indices NIL :type (simple-array idx (*)))
  (types NIL :type (simple-array (unsigned-byte 8) (*)))
  (levels NIL :type (simple-array (unsigned-byte 8) (*)))
  (level 0 :type (unsigned-byte 8))
  (sos 0 :type (unsigned-byte 8))
  (eos 0 :type (unsigned-byte 8)))

(defun make-isolating-run-sequence (indexes string paragraph-level result-types result-levels)
  (let ((types (make-array (length indexes) :element-type '(unsigned-byte 8))))
    (loop for i from 0 below (length indexes)
          do (setf (aref types i) (aref result-types (aref indexes i))))
    (let* ((level (aref result-levels (aref indexes 0)))
           (levels (make-array (length indexes) :element-type '(unsigned-byte 8) :initial-element level))
           (prev-char (1- (aref indexes 0))))
      (loop while (and (<= 0 prev-char) (removed-by-x9-p (class-at string prev-char)))
            do (decf prev-char))
      (let* ((prev-level (if (<= 0 prev-char)
                             (aref result-levels prev-char)
                             paragraph-level))
             (sos (type-for-level (max prev-level level)))
             (last-type (aref types (1- (length types))))
             (succ-level 0))
        (cond ((or (= last-type (class-id :LRI))
                   (= last-type (class-id :RLI))
                   (= last-type (class-id :FSI)))
               (setf succ-level paragraph-level))
              (T
               (let ((limit (1+ (aref indexes (1- (length indexes))))))
                 (loop while (and (< limit (length string))
                                  (removed-by-x9-p (class-at string limit)))
                       do (incf limit))
                 (setf succ-level (if (< limit (length string))
                                      (aref result-levels limit)
                                      paragraph-level)))))
        (let ((eos (type-for-level (max succ-level level))))
          (make-seq indexes types levels level sos eos))))))

(defun resolve-paired-brackets (seq string pairs)
  (let ((indices (seq-indices seq))
        (sos (seq-sos seq))
        (dir (if (= 1 (logand 1 level))
                 (class-id :R)
                 (class-id :L)))
        (types (seq-types seq))
        (openers ())
        (pair-positions ()))
    ;; locateBrackets
    (loop for i from 0 below (length indices)
          for type = (bracket-type (aref string (aref indices i)))
          do (unless (or (= type 0)
                         (/= (or (aref types i) (class-id :ON))))
               (case type
                 ;; Open
                 (1 (when (= (length openers) MAX-PAIRING-DEPTH)
                      (setf openers ())
                      (return))
                  (push i openers))
                 ;; Close
                 (2 (when openers
                      (loop for cons on openers
                            for opener = (car cons)
                            do (when (= (aref pairs (aref indices opener))
                                        (aref pairs (aref indices i)))
                                 (push pair-positions (cons opener i))
                                 (setf openers cons)
                                 (return))))))))
    ;; resolveBrackets
    (loop for pair in pair-positions
          for dir-pair = (classify-pair-content types pair dir)
          do (unless (= dir-pair (class-id :ON))
               (when (/= dir-pair dir)
                 (setf dir-pair (class-before-pair types sos pair))
                 (when (or (= dir-pair dir) (= dir-pair (class-id :ON)))
                   (setf dir-pair dir-embed))))
             (set-brackets-to-type string indices types pair dir))))

(defun normalize-strong-type-n0 (code)
  (cond ((= code (class-id :L))
         (class-id :L))
        ((or (= code (class-id :R))
             (= code (class-id :EN))
             (= code (class-id :AN))
             (= code (class-id :AL)))
         (class-id :R))
        (T
         (class-id :ON))))

(defun classify-pair-content (types pair dir-embed)
  (loop with opposite = (class-id :ON)
        for i from (1+ (car pair)) below (cdr pair)
        for dir = (normalize-strong-type-n0 (aref types i))
        do (unless (= dir (class-id :ON))
             (when (= dir dir-embed)
               (return dir))
             (setf opposite dir))
        finally (return opposite)))

(defun class-before-pair (types sos pair)
  (loop for i downfrom (1- (car pair)) to 0
        for dir = (normalize-strong-type-n0 (aref types i))
        do (when (/= dir (class-id :ON))
             (return dir))
        finally (return sos)))

(defun set-brackets-to-type (string indices types pair dir)
  (destructuring-bind (opener . closer) pair
    (setf (aref types opener) dir)
    (setf (aref types closer) dir)
    ;; Done twice just to skip the closer character... yeesh.
    (loop for i from (1+ opener) below closer
          for index = (aref indices i)
          do (if (= (class-at string index) (class-id :NSM))
                 (setf (aref types i) dir)
                 (loop-finish)))
    (loop for i from (1+ closer) below (length indices)
          for index = (aref indices i)
          do (if (= (class-at string index) (class-id :NSM))
                 (setf (aref types i) dir)
                 (loop-finish)))))

(defun find-run-limit (seq start end valid)
  (let ((types (seq-types seq)))
    (loop for i from start below end
          do (unless (find (aref types i) valid)
               (return i))
          finally (return end))))

(defun resolve-weak-types (seq)
  ;; FIXME: it feels like a lot of these loops could be combined.
  (let ((types (seq-types seq)))
    ;; W1
    (loop with preceeding-type = (seq-sos seq)
          for i from 0 below (length types)
          for type = (aref types i)
          do (cond ((= type (class-id :NSM))
                    (setf (aref types i) preceeding-type))
                   (T
                    ;; WTF: this seems redundant
                    (when (<= (class-id :LRI) type (class-id :PDI))
                      (setf preceeding-type (class-id :ON)))
                    (setf preceeding-type type))))
    ;; W2
    (loop for i from 0 below (length types)
          do (when (= (aref types i) (class-id :EN))
               (loop for j downfrom (1- i) to 0
                     for type = (aref types j)
                     do (when (or (= type (class-id :L))
                                  (= type (class-id :R))
                                  (= type (class-id :AL)))
                          (when (= type (class-id :AL))
                            (setf (aref types i) (class-id :AN)))
                          (loop-finish)))))
    ;; W3
    (loop for i from 0 below (length types)
          do (when (= (aref types i) (class-id :AL))
               (setf (aref types i) (class-id :R))))
    ;; W4 
    (loop for i from 1 below (1- (length types))
          for type = (aref types i)
          do (when (or (= type (class-id :ES))
                       (= type (class-id :CS)))
               (let ((prev-sep (aref types (1- i)))
                     (succ-sep (aref types (1+ i))))
                 (cond ((and (= prev-sep (class-id :EN))
                             (= succ-sep (class-id :EN)))
                        (setf (aref types i) (class-id :EN)))
                       ((and (= type (class-id :CS))
                             (= prev-sep (class-id :AN))
                             (= succ-sep (class-id :AN)))
                        (setf (aref types i) (class-id :AN)))))))
    ;; W5
    (loop for i from 0 below (length types)
          do (when (= (aref types i) (class-id :ET))
               (let* ((run-start i)
                      (run-limit (find-run-limit seq run-start (length types) (class-ids :ET)))
                      (type (if (= 0 run-start) (seq-sos seq) (aref types (1- run-start)))))
                 (when (/= type (class-id :EN))
                   (setf type (if (= run-limit (length types)) (seq-eos seq) (aref types run-limit))))
                 (when (= type (class-id :EN))
                   (fill types (class-id :EN) :start run-start :end run-limit))
                 (setf i run-limit))))
    ;; W6
    (loop for i from 0 below (length types)
          for type = (aref types i)
          do (when (or (= type (class-id :ES))
                       (= type (class-id :ET))
                       (= type (class-id :CS)))
               (setf (aref types i) (class-id :ON))))
    ;; W7
    (loop for i from 0 below (length types)
          do (when (= (aref types i) (class-id :EN))
               (let ((prev-strong-type (seq-sos seq)))
                 (loop for j downfrom (1- i) to 0
                       for type = (aref types j)
                       do (when (or (= type (class-id :L))
                                    (= type (class-id :R)))
                            (setf prev-strong-type type)
                            (loop-finish)))
                 (when (= prev-strong-type (class-id :L))
                   (setf (aref types i) (class-id :L))))))))

(defun resolve-neutral-types (seq)
  (let ((types (seq-types seq)))
    (loop for i from 0 below (length types)
          for type = (aref types i)
          do (when (or (<= (class-id :B) type (class-id :ON))
                       (<= (class-id :LRI) type (class-id :PDI)))
               (let* ((run-start i)
                      (run-limit (find-run-limit seq run-start (length types) (class-ids :B :S :WS :ON :RLI :LRI :FSI :PDI)))
                      leading-type trailing-type)
                 (cond ((= 0 run-start)
                        (setf leading-type (seq-sos seq)))
                       (T
                        (setf leading-type (aref types (1- run-start)))
                        (when (or (= leading-type (class-id :AN))
                                  (= leading-type (class-id :EN)))
                          (setf leading-type (class-id :R)))))
                 (cond ((= run-limit (length types))
                        (setf trailing-type (seq-eos seq)))
                       (T
                        (setf trailing-type (aref types run-limit))
                        (when (or (= trailing-type (class-id :AN))
                                  (= trailing-type (class-id :EN)))
                          (setf trailing-type (class-id :R)))))
                 (let ((resolved-type (if (= leading-type trailing-type)
                                          leading-type
                                          (type-for-level (seq-level seq)))))
                   (fill types resolved-type :start run-start :end run-limit)
                   (setf i run-limit)))))))

(defun resolve-implicit-levels (seq)
  (let* ((types (seq-types seq))
         (levels (seq-levels seq)))
    (cond ((= 0 (logand #x1 (seq-level seq)))
           (loop for i from 0 below (length types)
                 for type = (aref types i)
                 do (cond ((= type (class-id :L)))
                          ((= type (class-id :R))
                           (incf (aref levels i) 1))
                          (T
                           (incf (aref levels i) 2)))))
          (T
           (loop for i from 0 below (length types)
                 do (cond ((= (aref types i) (class-id :R)))
                          (T
                           (incf (aref levels i) 1))))))))

(defun apply-levels-and-types (seq result-types result-levels)
  (let ((indices (seq-indices seq))
        (types (seq-types seq))
        (levels (seq-levels seq)))
    (loop for i from 0 below (length types)
          for original-index = (aref indices i)
          do (setf (aref result-types original-index) (aref types i))
             (setf (aref result-levels original-index) (aref levels i)))))
