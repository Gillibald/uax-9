#|
 This file is a part of UAX-9
 (c) 2019 Shirakumo http://tymoon.eu (shinmera@tymoon.eu)
 Author: Nicolas Hafner <shinmera@tymoon.eu>
|#

(in-package #:org.shirakumo.alloy.uax-9)

(declaim (inline type-for-level))
(defun type-for-level (level)
  (if (= 0 (logand #x1 level))
      (class-id :L)
      (class-id :R)))

(defstruct (seq (:constructor make-seq (indices types levels))
                (:copier NIL))
  (indices NIL :type (simple-array idx (*)))
  (types NIL :type (simple-array (unsigned-byte 8) (*)))
  (levels NIL :type (simple-array (unsigned-byte 8) (*)))
  (level 0 :type (unsigned-byte 8))
  (sos 0 :type (unsigned-byte 8))
  (eos 0 :type (unsigned-byte 8)))

(defun make-isolating-run-sequence (input string level result-types result-levels)
  (let* ((types (make-array (length input) :element-type '(unsigned-byte 8)))
         (levels (make-array (length input) :element-type '(unsigned-byte 8)))
         (seq (make-seq (copy-seq input) types levels)))
    (loop for i from 0 below (length input)
          do (setf (aref types i) (aref result-types (aref input i))))
    (setf (seq-level seq) (aref result-levels (aref input 0)))
    (let ((prev-char (1- (aref input 0))))
      (loop while (and (<= 0 prev-char) (removed-by-x9-p (class-at string prev-char)))
            do (decf prev-char))
      (let ((prev-level (if (<= 0 prev-char) (aref result-levels prev-char) level)))
        (setf (seq-sos seq) (type-for-level (max prev-level (seq-level seq))))
        (let ((last-type (aref types (1- (length types))))
              (succ-level 0))
          (cond ((or (= last-type (class-id :LRI))
                     (= last-type (class-id :RLI))
                     (= last-type (class-id :FSI)))
                 (setf succ-level (seq-level seq)))
                (T
                 (let ((limit (1+ (aref input (1- (length input))))))
                   (loop while (and (< limit (length string))
                                    (removed-by-x9-p (class-at string limit)))
                         do (incf limit))
                   (setf succ-level (if (< limit (length string))
                                        (aref result-levels limit)
                                        level)))))
          (setf (seq-eos seq) (type-for-level (max succ-level (seq-level seq)))))))
    seq))

(defun resolve-paired-brackets (seq))

(defun find-run-limit (seq start end valid)
  (let ((types (seq-types seq)))
    (loop for i from start below end
          do (unless (find (aref types i) valid)
               (return i))
          finally (return end))))

(defun resolve-weak-types (seq)
  ;; FIXME: it feels like a lot of these loops could be combined.
  (let ((types (seq-types seq)))
    ;; W1
    (loop with preceeding-type = (seq-sos seq)
          for i from 0 below (length types)
          for type = (aref types i)
          do (cond ((= type (class-id :NSM))
                    (setf (aref types i) preceeding-type))
                   (T
                    ;; WTF: this seems redundant
                    (when (<= (class-id :LRI) type (class-id :PDI))
                      (setf preceeding-type (class-id :ON)))
                    (setf preceeding-type type))))
    ;; W2
    (loop for i from 0 below (length types)
          do (when (= (aref types i) (class-id :EN))
               (loop for j downfrom (1- i) to 0
                     for type = (aref types j)
                     do (when (or (= type (class-id :L))
                                  (= type (class-id :R))
                                  (= type (class-id :AL)))
                          (when (= type (class-id :AL))
                            (setf (aref types i) (class-id :AN)))
                          (loop-finish)))))
    ;; W3
    (loop for i from 0 below (length types)
          do (when (= (aref types i) (class-id :AL))
               (setf (aref types i) (class-id :R))))
    ;; W4 
    (loop for i from 1 below (1- (length types))
          for type = (aref types i)
          do (when (or (= type (class-id :ES))
                       (= type (class-id :CS)))
               (let ((prev-sep (aref types (1- i)))
                     (succ-sep (aref types (1+ i))))
                 (cond ((and (= prev-sep (class-id :EN))
                             (= succ-sep (class-id :EN)))
                        (setf (aref types i) (class-id :EN)))
                       ((and (= type (class-id :CS))
                             (= prev-sep (class-id :AN))
                             (= succ-sep (class-id :AN)))
                        (setf (aref types i) (class-id :AN)))))))
    ;; W5
    (loop for i from 0 below (length types)
          do (when (= (aref types i) (class-id :ET))
               (let* ((run-start i)
                      (run-limit (find-run-limit seq run-start (length types) (class-ids :ET)))
                      (type (if (= 0 run-start) (seq-sos seq) (aref types (1- run-start)))))
                 (when (/= type (class-id :EN))
                   (setf type (if (= run-limit (length types)) (seq-eos seq) (aref types run-limit))))
                 (when (= type (class-id :EN))
                   (fill types (class-id :EN) :start run-start :end run-limit))
                 (setf i run-limit))))
    ;; W6
    (loop for i from 0 below (length types)
          for type = (aref types i)
          do (when (or (= type (class-id :ES))
                       (= type (class-id :ET))
                       (= type (class-id :CS)))
               (setf (aref types i) (class-id :ON))))
    ;; W7
    (loop for i from 0 below (length types)
          do (when (= (aref types i) (class-id :EN))
               (let ((prev-strong-type (seq-sos seq)))
                 (loop for j downfrom (1- i) to 0
                       for type = (aref types j)
                       do (when (or (= type (class-id :L))
                                    (= type (class-id :R)))
                            (setf prev-strong-type type)
                            (loop-finish)))
                 (when (= prev-strong-type (class-id :L))
                   (setf (aref types i) (class-id :L))))))))

(defun resolve-neutral-types (seq)
  (let ((types (seq-types seq)))
    (loop for i from 0 below (length types)
          for type = (aref types i)
          do (when (or (<= (class-id :B) type (class-id :ON))
                       (<= (class-id :LRI) type (class-id :PDI)))
               (let* ((run-start i)
                      (run-limit (find-run-limit seq run-start (length types) (class-ids :B :S :WS :ON :RLI :LRI :FSI :PDI)))
                      leading-type trailing-type)
                 (cond ((= 0 run-start)
                        (setf leading-type (seq-sos seq)))
                       (T
                        (setf leading-type (aref types (1- run-start)))
                        (when (or (= leading-type (class-id :AN))
                                  (= leading-type (class-id :EN)))
                          (setf leading-type (class-id :R)))))
                 (cond ((= run-limit (length types))
                        (setf trailing-type (seq-eos seq)))
                       (T
                        (setf trailing-type (aref types run-limit))
                        (when (or (= trailing-type (class-id :AN))
                                  (= trailing-type (class-id :EN)))
                          (setf trailing-type (class-id :R)))))
                 (let ((resolved-type (if (= leading-type trailing-type)
                                          leading-type
                                          (type-for-level (seq-level seq)))))
                   (fill types resolved-type :start run-start :end run-limit)
                   (setf i run-limit)))))))

(defun resolve-implicit-levels (seq)
  (let* ((types (seq-types seq))
         (resolved-levels (make-array (length types) :element-type '(unsigned-byte 8) :initial-element (seq-level seq))))
    (cond ((= 0 (logand #x1 (seq-level seq)))
           (loop for i from 0 below (length types)
                 for type = (aref types i)
                 do (cond ((= type (class-id :L)))
                          ((= type (class-id :R))
                           (incf (aref resolved-levels i) 1))
                          (T
                           (incf (aref resolved-levels i) 2)))))
          (T
           (loop for i from 0 below (length types)
                 do (cond ((= (aref types i) (class-id :R)))
                          (T
                           (incf (aref resolved-levels i) 1))))))))

(defun apply-levels-and-types (seq result-types result-levels)
  (let ((indices (seq-indices seq))
        (types (seq-types seq))
        (levels (seq-levels seq)))
    (loop for i from 0 below (length types)
          for original-index = (aref indices i)
          do (setf (aref result-types original-index) (aref types i))
             (setf (aref result-levels original-index) (aref levels i)))))
